<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta id="metaTitle" name="title" content="Game Title">
    <meta id="metaDescription" name="description" content="Game description">
    <meta id="metaImage" name="image" property="og:image"/>
    <link id="faviconID" rel="icon" href="">
    <meta name="keywords" content="Visual Novel, Video Game">
    <script src="https://unpkg.com/vue@next"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.1/howler.min.js"></script>
    <script src="libEngine.js"> </script>
    <script src="customFunction.js"> </script>
    <script src="engine_assets.js"> </script>
    <script type="text/javascript" src="assets.json"></script>
    <link rel="stylesheet" href="styleEngine.css">
    <title id="titleGame"> Game </title>
</head>
<body>
<div id="app">
</div>
</body>
</html>

<script>
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    const app = Vue.createApp({
        template:
        // ################# CHARACTERS #################
            '<div id="characters-module" :style="{gridTemplateColumns : columnsCharacterDiv}">' +
            '  <div class="character-div" v-for="(char,index) in listCharactersInScene" :key="char.name+index" :style="{gridColumn : char.gridColumn}">\n' +
            '    <img class="character-img unselectable" :style="{height : \'calc(100% * \'+char.size+\')\'}" :src="\'Assets/Characters/\'+char.img" draggable="false" @mousedown="() => {return false}" @dragstart="() => {return false}">' +
            '  </div>\n' +
            '</div>' +

            // ################# INPUT DIALOGUE #################
            '<div id="input-module" :class="{show: askinput}">' +
            '        <div id="inputLoc">' +
            '            <input :type="inputtype" id="inputText" :class="{invalidtext : !canSubmit}" v-model="input" required> \n' +
            '            <button class="unselectable buttonClass" id="inputButton" @click="submitInput" :disabled="!canSubmit"> Submit </button>' +
            '        </div>' +
            '</div>' +

            // ################# DIALOGUE BLOCK TEXT #################
            '<div id="dialogue-module" :class="{up: inChoices && !hideText, hide: hideText || showInventory}">' +
            '    <div v-if="currentCharacter !== \'\'" id="speaker-block">' +
            '        <p id="character-speaker" class="unselectable"> <strong> {{ currentCharacter }} </strong> </p>\n' +
            '    </div>' +
            '    <div ref="dialogueBlock" id="dialogue-block" @click="clickText()"> ' +
            '        <p id="dialogue-text" class="unselectable"> {{ currentText }} </p>\n' +
            '    </div>' +
            '</div>' +

            // ################# CHOICES MODULE #################
            '<div id="choice-module" :style="{pointerEvents: pointerEventsChoiceModule}" :class="{hide: showInventory}">' +
            '    <div ref="choicePanel" id="choice-block" :class="{show: inChoices}" :style="{transitionDelay: transitionDelayChoicesBlock}"> ' +
            '        <div id="choice-row">' +
            '            <button class="unselectable buttonClass pageButton" :class="{hide: disableBackPageChoiceButtons}" @click="backPageChoice"> &lt </button>' +
            '            <div id="choicesLoc" :style="{paddingTop: paddingTopChoiceBlock}" :class="{grid2choices : currentChoicePageList.length <= 2, grid3choices : currentChoicePageList.length === 3, grid4choices : currentChoicePageList.length === 4, grid5choices : currentChoicePageList.length === 5, grid6choices : currentChoicePageList.length === 6, grid7choices : currentChoicePageList.length === 7, grid8choices : currentChoicePageList.length === 8}">' +
            '                <button v-for="(choice, index) in currentChoicePageList" @click="clickChoice(choice.index)" class="unselectable buttonClass" :style="{gridColumn: getColumnChoice(index), gridRow : getRowChoice(index)}"> {{ choice.text }} </button>' +
            '            </div>' +
            '            <button class="unselectable buttonClass pageButton" :class="{hide: disableNextPageChoiceButtons}" @click="nextPageChoice"> > </button>' +
            '        </div>'+
            '    </div>' +
            '</div>' +

            // ################# INVENTORY #################
            '<button id="inventoryButton" :class="{show: inChoices && !showInventory}" class="unselectable buttonClass" @click="showInventoryPanel">  Inventory </button>' +

            '<div id="inventory-background-overlay" :class="{show : showInventory}" @click="showInventory = false"></div>' +
            '<div id="inventory-module" :class="{inventoryclosed : !showInventory}">' +
            '    <h1 class="unselectable"> Inventory : </h1>' +
            '    <div id="inventory-container">' +
            '        <button v-for="(item, index) in inventory" :key="index+item.name" class="buttonClass unselectable item-button" @click="clickiteminventory(index)">\n' +
            '            <img class="img-item" :src="\'Assets/Objects/\'+item.img">\n' +
            '            <p class="text-item"> {{ item.name }} {{ amountItemInventoryText(item) }}</p>\n' +
            '        </button>' +
            '    </div>' +
            '    <button id="inventory-button-exit" class="unselectable buttonClass" @click="showInventory = false">  Exit </button>' +
            '</div>',

        mixins: [mix_engine],

        data: () => ({
            hideText: false, // When true, the dialogue block/text is hidden
            page : "null", // The page of nodes where we are currently playing in
            currentDialogueIndex : -1, // Index of the current executed node in the current page
            currentText : "", // The text currently displayed in the dialogue block
            currentCharacter : "test", // The Character name currently displayed in the dialogue speaker block
            canPassDialogue : true, // When true, the current dialogue is skippable (false with Input & Choice node for example)
            animationText : null, // Store the interval in charge of the text animation (if null : no text animation is currently used)
            assets : assets, // Store all the nodes, data, assets of the game.
            allText : "", // All the text (that will be)/(which is) displayed of the current dialogue.
            askinput : false, // When true, input UI will be displayed for asking input to the user
            input : "", // The input text entered by the player
            inputtype : "text", // Type of input asked to the player (text or number)
            minInput : 0, // Minimum Number for number input , Minimum characters count for text input
            maxInput : 100, // Maximum Number for number input , Maximum characters count for text input
            inChoices : false, // When true, the choices ui is displayed
            listChoice : [], // List of the choices that the player has currently
            inventory : [], // List of all the items the player has in his/her inventory.
            listObjectChoice : [], // List of inventory items that can be used as a choice in the current dialogue
            currentChoicePage : 0, // The current page of choice (used when there are more than 8 choices)
            showInventory: false, // When true, the inventory UI is displayed
            listCharactersInScene : [], // The list of all characters that are currently in the scene
            listMusics : [], // List of the musics that are currently played
            listSounds : [],// List of the sounds that are currently played
            canGoNext : false, // When true, the player can skip to the next dialogue (false when executing script that are not skippable for example)
            textSoundID : 0, // ID of the text sound, use to get it / stop it
            choicePanelRef: null, // Reference of choice panel DOM element
        }),

        mounted() {
            // loading initial page and dialogue (useful when loading the game through a specific dialogue node)
            if(urlParams.get('page') !== null) this.page = urlParams.get('page');
            if(urlParams.get('dialogue') !== null) this.currentDialogueIndex = parseInt(urlParams.get('dialogue'));
            if(this.assets === null) return;

            // Setting the meta data
            document.getElementById("titleGame").innerHTML = this.assets[8].content.displayname;
            document.getElementById("metaTitle").setAttribute('content', this.assets[8].content.displayname);
            document.getElementById("metaDescription").setAttribute('content', this.assets[8].content.description);
            if(this.assets[8].content.banner !== "") document.getElementById("metaImage").setAttribute('content', this.assets[8].content.banner);
            if(this.assets[8].content.icon !== "") document.getElementById("faviconID").setAttribute('href', this.assets[8].content.icon);

            // Starting the game
            this.playInitialDialogue();

            this.choicePanelRef = this.$refs.choicePanel;
        },

        computed:{
            // Inidicate if the user can submit his/her input. (if the input il valid)
            canSubmit(){
                if(this.inputtype === "text"){
                    return this.input !== "" && this.input.length >= this.minInput && this.input.length <= this.maxInput;
                } else if (this.inputtype === "number"){
                    try {
                        let n = parseInt(this.input);
                        return n>= this.minInput && n<= this.maxInput;
                    } catch {
                        return false;
                    }
                }
                return false;
            },
            // When true, next page button for choices is disabled
            disableNextPageChoiceButtons(){
                return this.listChoice.length <= this.currentChoicePage*8+8;
            },
            // When true, previous page button for choices is disabled
            disableBackPageChoiceButtons(){
                return this.currentChoicePage === 0;
            },
            // return the page number of choices
            currentChoicePageList(){
                return this.listChoice.slice(this.currentChoicePage*8, Math.min(this.currentChoicePage*8+8, this.listChoice.length));
            },
            // return the css column numbers depending of the number of characters in the scene
            columnsCharacterDiv(){
                return (this.listCharactersInScene.length<2 ? 'repeat(3, 33%)' : 'repeat('+this.listCharactersInScene.length+','+parseInt(100 / this.listCharactersInScene.length)+'%)');
            },
            // return the css pointer event value for choice module
            pointerEventsChoiceModule(){
                return (this.inChoices ? "all" : "none");
            },
            // return the css transition delay value for choice module
            transitionDelayChoicesBlock(){
                return (this.inChoices ? "0.2s" : "0s");
            },
            // return the css padding top value for choice module
            paddingTopChoiceBlock(){
                return (this.currentChoicePageList.length === 3 ? "0" : "2%");
            },
        },

        methods:{
            // ######################### INITIAL LOADING ###############################
            playInitialDialogue(){
                if(this.page === "null" && this.currentDialogueIndex === -1) this.setInitialDialogue();

                const dialogue = getDialogue(this.page, this.currentDialogueIndex, this.assets);
                this.playDialogue(dialogue, this.currentDialogueIndex);
            },
            setInitialDialogue(){
                this.assets[6].content.forEach((p) => {
                    let i = 0;
                    p.listDialogues.forEach((d) => {
                        if(d.initial !== undefined && d.initial){
                            this.page = p.title;
                            this.currentDialogueIndex = i;
                            return;
                        }
                        i++;
                    });
                });
            },

            // ######################### DIALOGUES MANAGEMENT #########################
            playDialogue(dialogue, index){
                this.canGoNext = (dialogue.waitEndScript === undefined ? true : !dialogue.waitEndScript);
                this.canPassDialogue = !(dialogue.type === "choices" || dialogue.type === "input");
                this.currentDialogueIndex = index;

                if(dialogue.action !== undefined){
                    let actions = JSON.parse(JSON.stringify(dialogue.action));
                    if(actions.length > 0) {
                        let callbackAction = () => {
                            if(actions.length > 0) this.executeActionScript(actions.shift(),callbackAction);
                            else{
                                if(dialogue.type === "function" && !this.canGoNext) this.playNextDialogue(0);
                                this.canGoNext = true;
                            }
                        };
                        this.executeActionScript(actions.shift(),callbackAction);
                    }
                }

                if(dialogue.type === "function" && this.canGoNext){
                    this.playNextDialogue(0);
                }

                if(dialogue.tabs.includes("Dialogue")){
                    let character = getVariableValue(dialogue.speaker, this.assets);
                    if(character === null || character === "null") character = dialogue.speakernull;
                    this.hideText = dialogue.text.length === 0 && dialogue.type !== "dialogue";
                    this.showText(dialogue.text, character);
                }

                if(dialogue.type === "choices"){
                    this.inChoices = true;
                    this.listChoice = [];
                    this.listObjectChoice = [];
                    this.currentChoicePage = 0;

                    let i = 0;
                    let ref = this;
                    dialogue.choices.forEach((c) => {
                        if(c.type === "choice"){
                            let value = getVariableValue(c.condition, ref.assets);
                            if(value === null || value === "null") value = false;
                            if(value){
                                ref.listChoice.push({ text : c.text, index : i});
                            }
                        } else if(c.type === "object"){
                            let value = getVariableValue(c.object, ref.assets);
                            if(!(value === null || value === "null")) {
                                ref.listObjectChoice.push({ object : value, index : i});
                            }
                        }
                        i++;
                    });
                }

                if(dialogue.type === "input"){
                    this.askinput = true;
                    this.input = "";
                    if(dialogue.input !== undefined){
                        if(dialogue.input.type.name === "String"){
                            this.inputtype = "text";
                        }
                        if(dialogue.input.type.name === "Integer"){
                            this.inputtype = "number";
                        }
                        this.minInput = dialogue.minInput;
                        this.maxInput = dialogue.maxInput;
                    }
                }

                if(dialogue.type === "condition"){
                    var value = getVariableValue(dialogue.condition, this.assets);
                    if(value === null || value === "null") value = false;
                    if(value){
                        this.playNextDialogue(1);
                    } else {
                        this.playNextDialogue(0);
                    }
                }

                if(dialogue.type === "transition"){
                    if(dialogue.transitionpage !== undefined && dialogue.transitionpage !== ""){
                        const arrival = getTransitionDialogue(dialogue.transitionpage, dialogue.id, this.assets);
                        if(arrival !== null){
                            this.page = dialogue.transitionpage;
                            this.playDialogue(arrival.d, arrival.index);
                        }
                    }
                    if(dialogue.nextDialogue.length>0 && this.canGoNext){
                        this.playNextDialogue(0);
                    }
                }

            },
            playNextDialogue(index, fromchoice = false){
                const dialogue = getDialogue(this.page, this.currentDialogueIndex, this.assets);
                if(dialogue.nextDialogue[index] !== undefined && dialogue.nextDialogue[index].id !== -1){
                    if(fromchoice){
                        this.inChoices = false;
                        this.showInventory = false;
                    }
                    this.playDialogue(getDialogue(this.page, dialogue.nextDialogue[index].id, this.assets), dialogue.nextDialogue[index].id);
                }
            },

            // ######################### TEXT MANAGEMENT ###############################
            showText(text, character){
                this.currentText = "";
                this.allText = text;
                let regex = /\${((\w|\s)+)}/g;

                const listMatch = [...text.matchAll(regex)];
                listMatch.forEach((m) => {
                    const value = getVariableValueByName(m[1], this.assets);
                    if(value === "null" || value === null) this.allText = this.allText.replace(m[0], "");
                    else this.allText = this.allText.replace(m[0], value);
                });

                this.currentCharacter = character;
                const charList = this.allText.split("");

                let sound = getVariableValue(this.assets[8].content.defaultTextSound, this.assets);
                if(sound !== "null" && sound !== null){
                    let soundAsset = getSound(sound, this.assets);
                    if(soundAsset !== null){
                        this.textSoundID = this.playSound(soundAsset, sound, true);
                    }
                }



                this.animationText = setInterval(() => {
                    if(charList.length>0) this.currentText += charList.shift();
                    else this.stopAnimationText();
                    this.$refs.dialogueBlock.scrollTop = this.$refs.dialogueBlock.scrollHeight;
                }, 10)
            },
            stopAnimationText(){
                this.removeEndSound(this.textSoundID);
                clearInterval(this.animationText);
                this.animationText = null;
                this.currentText = this.allText;
                setTimeout(() => {
                    this.$refs.dialogueBlock.scrollTop = this.$refs.dialogueBlock.scrollHeight;
                }, (50))
            },
            clickText(){
                let sound = getVariableValue(this.assets[8].content.defaultClickSound, this.assets);
                if(sound !== "null" && sound !== null){
                    let soundAsset = getSound(sound, this.assets);
                    if(soundAsset !== null){
                        this.playSound(soundAsset, sound);
                    }
                }
                if(this.animationText === null) {
                    if(this.canPassDialogue && this.canGoNext){
                        this.playNextDialogue(0);
                    }
                } else {
                    this.stopAnimationText();
                }
            },

            // ######################### INPUT MANAGEMENT ##############################
            submitInput() {
                if(this.canSubmit){
                    const dialogue = getDialogue(this.page, this.currentDialogueIndex, this.assets);
                    let newvalue = this.input;
                    if(this.inputtype === "number") newvalue = parseInt(newvalue);
                    setValueVariableByName(dialogue.input.value.value, newvalue,  this.assets);
                    this.askinput = false;
                    this.playNextDialogue(0);
                }
            },

            // #################### CHOICE & INVENTORY MANAGEMENT ######################
            clickChoice(index){
                this.playNextDialogue(this.currentChoicePage*8 + index, true);
            },
            getColumnChoice(index){
                if(this.currentChoicePageList.length < 4){
                    /*if(this.currentChoicePageList.length === 1) return '1 / 3';
                    return index+1;*/
                    return 1;
                } else if(this.currentChoicePageList.length === 4){
                    return index%2 + 1;
                } else if(this.currentChoicePageList.length === 5){
                    switch(index){
                        case 0:
                            return '1 / 3';
                        case 1:
                            return '3 / 5';
                        case 2:
                            return '5 / 7';
                        case 3:
                            return '2 / 4';
                        case 4:
                            return '4 / 6';
                    }
                }else if(this.currentChoicePageList.length === 6){
                    return index%3 + 1;
                } else if(this.currentChoicePageList.length === 7){
                    switch(index){
                        case 0:
                            return '1 / 3';
                        case 1:
                            return '3 / 5';
                        case 2:
                            return '5 / 7';
                        case 3:
                            return '7 / 9';
                        case 4:
                            return '2 / 4';
                        case 5:
                            return '4 / 6';
                        case 6:
                            return '6 / 8';
                    }
                }else if(this.currentChoicePageList.length === 8){
                    return index%4 + 1;
                }
            },
            getRowChoice(index){
                if(this.currentChoicePageList.length < 4){
                    return index+1;
                } else if(this.currentChoicePageList.length === 4){
                    if(index<=1) return 1;
                    return 2;
                } else if(this.currentChoicePageList.length === 5){
                    if(index<=2) return 1;
                    return 2;
                }else if(this.currentChoicePageList.length === 6){
                    if(index<=2) return 1;
                    return 2;
                }else if(this.currentChoicePageList.length <=8 ){
                    if(index<=3) return 1;
                    return 2;
                }
            },
            nextPageChoice(){
                if(!(this.disableNextPageChoiceButtons)){
                    this.currentChoicePage++;
                }
            },
            backPageChoice(){
                if(!(this.disableBackPageChoiceButtons)){
                    this.currentChoicePage--;
                }
            },
            showInventoryPanel(){
                this.showInventory = true;
            },
            clickiteminventory(index){
                const list = this.listObjectChoice.filter((o) => o.object === this.inventory[index].name);
                if(list.length > 0) {
                    this.playNextDialogue(list[0].index, true);
                }
            },
            amountItemInventoryText(item){
                return  (item.amount > 1 ? 'x'+item.amount : '');
            },

            // ################### CHARACTER MANGAMENT ###################################
            resetCharactersLocation(){
                if(this.listCharactersInScene.length === 1){
                    this.listCharactersInScene[0].gridColumn = 2;
                } else if(this.listCharactersInScene.length === 2){
                    this.listCharactersInScene[0].gridColumn = 1;
                    this.listCharactersInScene[1].gridColumn = 2;
                } else {
                    for(let i = 0; i<this.listCharactersInScene.length; i++){
                        this.listCharactersInScene[i].gridColumn = i+1;
                    }
                }
            },

            // ################### SOUND MANAGEMENT ######################################
            removeEndSound(id){
                const index = this.listSounds.findIndex((s) => s.id === id);
                if(index !== -1){
                    this.listSounds[index].howl.stop();
                    this.listSounds[index].howl = null;
                    this.listSounds.splice(index, 1);
                }
            },
            playSound(asset, name, loop = false){
                const ref = this;
                const id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                this.listSounds.push({
                    name : name,
                    volume : asset.volume,
                    id :id,
                    howl : new Howl({
                        src: ["Assets/Sounds/"+asset.path],
                        autoplay: true,
                        loop: loop,
                        volume: asset.volume/100,
                        onend: function() {
                            if(!loop)ref.removeEndSound(id);
                        }
                    })
                });
                return id;
            },

            // ################### SCRIPT MANAGEMENT ######################################
            executeActionScript(action, callback){
                let execCallback = true;
                if(action.code !== undefined && action.code !== ""){
                    this[action.name](action.inputs);
                }
                if(action.enable !== undefined && !action.enable){
                    if(execCallback) callback();
                    return;
                }
                switch(action.name){
                    case "Change Background":
                        let scene = getVariableValue(action.inputs[0], this.assets);
                        if(scene === "null" || scene === null) break;
                        let sceneObject = getScene(scene, this.assets);
                        if(sceneObject === null) break;
                        document.body.style.backgroundImage = "url('Assets/Scenes/"+ sceneObject.img +"')";
                        break;
                    case "Give Object":
                        let object = getVariableValue(action.inputs[0], this.assets);
                        if(object === "null" || object === null) break;
                        let amount = getVariableValue(action.inputs[1], this.assets);
                        if(amount === "null" || amount === null || amount === 0) break;
                        let objectAsset = getObject(object, this.assets);
                        if(objectAsset === null) break;
                        let sameItemInventory = this.inventory.filter((i) => i.name === object);
                        if(sameItemInventory.length>0){
                            sameItemInventory[0].amount += amount;
                        } else {
                            this.inventory.push({name : object, amount : amount, img: objectAsset.img});
                        }
                        break;
                    case "Remove Object":
                        let objectToRemove = getVariableValue(action.inputs[0], this.assets);
                        if(objectToRemove === "null" || objectToRemove === null) break;
                        let amountToRemove = getVariableValue(action.inputs[1], this.assets);
                        if(amountToRemove === "null" || amountToRemove === null || amountToRemove === 0) break;
                        let index = this.inventory.findIndex((i) => i.name === objectToRemove);
                        if(index !== -1){
                            this.inventory[index].amount -= amountToRemove;
                            if(this.inventory[index].amount <= 0){
                                this.inventory.splice(index, 1);
                            }
                        }
                        break;
                    case "If":
                        let condition = getVariableValue(action.inputs[0], this.assets);
                        if(condition === "null" || condition === null || !condition || action.action === undefined) break;

                        let actions = JSON.parse(JSON.stringify(action.action));
                        if(actions.length>0){
                            execCallback = false;
                            let callbackAction = () => {
                                if(actions.length > 0) this.executeActionScript(actions.shift(),callbackAction);
                                else callback();
                            };
                            this.executeActionScript(actions.shift(),callbackAction);
                        }
                        break;
                    case "If Else":
                        let conditionIf = getVariableValue(action.inputs[0], this.assets);
                        if(conditionIf === "null" || conditionIf === null) break;

                        let actionsIfElse = [];
                        let callbackActionIfElse = () => {
                            if(actionsIfElse.length > 0) this.executeActionScript(actionsIfElse.shift(),callbackActionIfElse);
                            else callback();
                        };

                        if(conditionIf){
                            if(action.actionif === undefined) break;
                            actionsIfElse = JSON.parse(JSON.stringify(action.actionif));
                        } else {
                            if(action.actionelse === undefined) break;
                            actionsIfElse = JSON.parse(JSON.stringify(action.actionelse));
                        }
                        if(actionsIfElse.length>0){
                            execCallback = false;
                            this.executeActionScript(actionsIfElse.shift(),callbackActionIfElse);
                        }
                        break;
                    case "Delay":
                        let delay = getVariableValue(action.inputs[0], this.assets);
                        if(delay === "null" || delay === null || delay === 0.0) break;
                        execCallback = false;
                        setTimeout(() => {callback();}, delay*1000);
                        break;
                    case "Set":
                        let variable = getVariableValue(action.inputs[0], this.assets);
                        if(variable === "null" || variable === null) break;
                        let value = getVariableValue(action.inputs[1], this.assets);
                        if(value === null) break;
                        setValueVariableByName(variable, value, this.assets);
                        break;
                    case "Set Random Integer":
                    case "Set Random Float":
                        let variableRI = action.inputs[0].value.value
                        if(variableRI === "null" || variableRI === null || variableRI === "") break;
                        let minInt = getVariableValue(action.inputs[1], this.assets);
                        if(minInt === "null" || minInt === null) break
                        let maxInt = getVariableValue(action.inputs[2], this.assets);
                        if(maxInt === "null" || maxInt === null) break
                        let newRandomInt = Math.random() * (maxInt - minInt) + minInt;
                        if(action.name === "Set Random Integer") newRandomInt = Math.floor(newRandomInt);
                        setValueVariableByName(variableRI, newRandomInt, this.assets);
                        break;
                    case "Add Character":
                        let character = getVariableValue(action.inputs[0], this.assets);
                        if(character === "null" || character === null) break;
                        let characterAsset = getCharacter(character, this.assets);
                        if(characterAsset === null) break;
                        if(this.listCharactersInScene.filter((c) => c.name === characterAsset.name).length === 0){
                            this.listCharactersInScene.push({name : characterAsset.name, size : characterAsset.size, img : characterAsset.img, gridColumn:{}});
                            this.resetCharactersLocation();
                        }
                        break;
                    case "Set Character State":
                        let characterS = getVariableValue(action.inputs[0], this.assets);
                        if(characterS === "null" || characterS === null) break;
                        let charList = this.listCharactersInScene.filter((c) => c.name === characterS);
                        if(charList.length===0) return;
                        let characterAssetS = getCharacter(characterS, this.assets);
                        if(characterAssetS === null) break;
                        let nameState = getVariableValue(action.inputs[1], this.assets);
                        if(nameState === "null" || nameState === null || nameState === "") break;
                        let listState = characterAssetS.imgOthers.filter((i) => i.name === nameState);
                        if(listState.length>0){
                            charList[0].img = listState[0].img;
                        }
                        break;
                    case "Remove Character":
                        let characterTR = getVariableValue(action.inputs[0], this.assets);
                        if(characterTR === "null" || characterTR === null) break;
                        let characterAssetTR = getCharacter(characterTR, this.assets);
                        if(characterAssetTR === null) break;
                        const indexTR = this.listCharactersInScene.findIndex((c) => c.name === characterAssetTR.name);
                        if(indexTR !== -1){
                            this.listCharactersInScene.splice(indexTR, 1);
                            this.resetCharactersLocation();
                        }
                        break;
                    case "Play Music":
                        let music = getVariableValue(action.inputs[0], this.assets);
                        if(music === "null" || music === null) break;
                        let musicAsset = getMusic(music, this.assets);
                        if(musicAsset === null) break;
                        const indexM = this.listMusics.findIndex((m) => m.name === music);
                        if(indexM === -1){
                            this.listMusics.push(
                                {
                                    name : music,
                                    volume : musicAsset.volume,
                                    howl : new Howl({
                                        src: ["Assets/Musics/"+musicAsset.path],
                                        autoplay: true,
                                        loop: true,
                                        volume: musicAsset.volume/100})
                                });
                        } else {
                            this.listMusics[indexM].howl.stop();
                            this.listMusics[indexM].howl.play();
                        }
                        break;
                    case "Stop Music":
                        let musicTR = getVariableValue(action.inputs[0], this.assets);
                        if(musicTR === "null" || musicTR === null) break;
                        const indexMTR = this.listMusics.findIndex((m) => m.name === musicTR);
                        if(indexMTR !== -1){
                            this.listMusics[indexMTR].howl.stop();
                            this.listMusics[indexMTR].howl = null;
                            this.listMusics.splice(indexMTR, 1);
                        }
                        break;
                    case "Play Sound":
                        let sound = getVariableValue(action.inputs[0], this.assets);
                        if(sound === "null" || sound === null) break;
                        let soundAsset = getSound(sound, this.assets);
                        if(soundAsset === null) break;
                        this.playSound(soundAsset, sound);
                        break;
                    case "Stop Sound":
                        let soundTR = getVariableValue(action.inputs[0], this.assets);
                        if(soundTR === "null" || soundTR === null) break;
                        this.listSounds.filter((s) => s.name === soundTR).forEach((s) => {
                            s.howl.stop();
                            s.howl = null;
                        });
                        this.listSounds = this.listSounds.filter((s) => s.name !== soundTR);
                        break;
                }
                if(execCallback) callback();
            },

            // ################### CUSTOM FUNCTION UTILS ##################################
            getInputValue(input){
                return getVariableValue(input, this.assets);
            },
        }
    });

    app.mount("#app");

</script>